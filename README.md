# redislock
实现一个redis分布式锁，分布式锁，简单来说就是在分布式环境下不同实例之间抢一把锁

分布式锁之所以难，**基本上都和网络有关**

# 设计思路
1、实现一个分布式锁的起点，就是利用 setnx 命令， 确保可以排他地设置一个键值对，如果key已经存在则返回报错，否则设置值

2、本质上Redis 的分布式锁就是一个键值对。

3、释放锁、自动续约的操作定义在Lock上，而非Client, 更符合面向对象的定义

4、必须设置锁的过期时间，如果没有设置，那么如果原本设置锁的实例崩溃了将永远不会有人去释放锁，其他实例永远无法获得锁，但是这样会带来一个问题，如果
在过期时间内业务未完成该如何处理呢？这就需要增加**续约**的功能！

5、加锁重试有多种情况需要考虑，比如超时（此时可能设置成功了也可能失败了），锁已经被别人占用

6、健值对的值不能设置为固定值，而要使用uuid等唯一性的值, **本质上，我们就是需要一个唯一的值，用来比较这是某个实例加的锁**，
所以在释放锁的时候需要判断是不是自己的锁再释放，避免把别人设置的锁释放了！

7、释放锁时，检测是不是自己的锁+释放锁这是两个动作，会有并发问题，所以要使用lua脚本来执行

8、单元测试不会使用真实的 Redis，而是使用 gomock工具,集成测试我们会启动 Redis. **严格意义上来说，单元测试不能依赖于任何的第三方组件，而只能使用mock 工具。**

9、我们使用的其实是 redis.Cmdable 的类型，它是一个接口，本质上就是为了我们能够在测试阶段注入一个mock 实现。


## 手动续约
Refresh 方法本身很简单，难其实难在使用的时候：
* 第一个问题：间隔多久续约一次？这个跟网络、Redis 服务器的稳定性有关
* 第二个问题：如果 Refresh 返回了 error，怎么处理？ 我选择的是超时错误就重试，其他错误返回给用户
* 第三个问题：如果确认续约失败了， 怎么中断后续的业务？这个问题基本无解，因为业务代码一旦执行，你除非自己手动检测分布式锁，并且手动中断，不然是没有办法的。


## 自动续约
这种自动续约的 API 还是很难设计的，因为用户自己手动续约要面对的问题，我们一样要面对：
* 隔多久续约，续多长？这里我们让用户来指定多久续约一次，因为这个跟网络、Redis 服务器的稳定性有关，而每次续多长，我们就直接使用原本的过期时间。
* 如何处理超时，以及超时设置多长时间？我们选择再次尝试续约。超时意味着也不知道究竟有没有续约成功，而且大多数时候超时都是偶发性的，所以可以立刻再次尝试。缺点就是如果此时真的Redis服务器崩溃或者网络不通，那么会导致无限次尝试续约，超时时间我们让用户指定。
* 如何通知用户续约失败？我们只处理超时引起的续约失败，其它情况下告诉用户遇到了无法处理的error。
* 要不要设置续约次数上限？例如一个业务，不断续约以至于十分钟都没释放分布式锁，要不要强制释放。我们的答案是不设置，理由依旧是如果用户有这种需求，他应该自己手动续约。

自动续约的可控性非常差，因此并不是很鼓励用户使用这个API。甚至于如果用户想要万无一失地使用这个布式锁，那么必须要自己手动调用 Refersh，并且小心处理各种 error。

此外，续约的间隔，应该综合考虑服务可用性。如果我们将分布式锁的过期时间设置为10秒，而且预期2秒内绝大概率续约成功，那么就可以考虑将续约间隔设置为8秒。

## 加锁重试
加锁可能遇到偶发性的失败，在这种情况下，可以尝试重试。重试逻辑：
* 超时了：这种情况下都不知道锁有没有拿到
* 此时正有人持有锁，我们要等别人释放锁

## singleflight
在非常高并发并且热点集中的情况下，可以考虑结合 singleflight 来进行优化。也就是说，本地所有的 goroutine 自己先竞争一把，胜利者再去抢全局的分布式锁。


# gomock 进行单元测试

在项目根目录下运行 mockgen命令，在当前mocks目录下会生成一个mock_redis_cmdable.gen.go文件：
```mockgen -destination=mocks/mock_redis_cmdable.gen.go -package=mocks github.com/redis/go-redis/v9 Cmdable```

参数意义：
* package：指定生成代码的 Go 代码的 package 的值
* destination：目标位置，我们这里是写到了一个文件里面
* github.com/go-redis/redis/v9
* Cmdable：表示为该包下面的 Cmdable 接口生成 mock 代码

## Client核心接口设计
```
TryLock： 加锁一次（可能失败），也就是用setnx排他性的设置一个健值对
Lock： 加锁重试
SingleflightLock: singleflight优化加锁
```

## Lock核心接口设计
```
Unlock： 释放锁
Refresh：手动续约
AutoRefresh： 自动续约
```

